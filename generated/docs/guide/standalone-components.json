{
  "id": "guide/standalone-components",
  "title": "Getting started with standalone components",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/standalone-components.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"getting-started-with-standalone-components\" translation-result=\"on\">独立组件入门<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#getting-started-with-standalone-components\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"getting-started-with-standalone-components\">Getting started with standalone components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#getting-started-with-standalone-components\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">在 v14 及更高版本中，<strong>独立组件</strong>提供了一种简化的方式来构建 Angular 应用程序。独立组件、指令和管道旨在通过减少对 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的需求来简化创作体验。现有应用程序可以选择性地以增量方式采用新的独立风格，而无需任何重大更改。</p><p translation-origin=\"off\">In v14 and higher, <strong>standalone components</strong> provide a simplified way to build Angular applications. Standalone components, directives, and pipes aim to streamline the authoring experience by reducing the need for <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. Existing applications can optionally and incrementally adopt the new standalone style without any breaking changes.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">独立组件特性可用于开发人员预览。它已准备好供你尝试；但它可能会在稳定之前发生变化。</p><p translation-origin=\"off\">The standalone component feature is available for developer preview.\nIt's ready for you to try; but it might change before it is stable.</p>\n\n</div>\n<h2 id=\"creating-standalone-components\" translation-result=\"on\">创建独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#creating-standalone-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"creating-standalone-components\">Creating standalone components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#creating-standalone-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"the-standalone-flag-and-component-imports\" translation-result=\"on\"><code>standalone</code> 标志和组件 <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#the-standalone-flag-and-component-imports\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"the-standalone-flag-and-component-imports\">The <code>standalone</code> flag and component <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#the-standalone-flag-and-component-imports\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">组件、指令和管道现在可以标记为 <code>standalone: true</code>。标记为独立的 Angular 类不需要在 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中声明（如果你尝试，Angular 编译器会报告错误）。</p><p translation-origin=\"off\">Components, directives, and pipes can now be marked as <code>standalone: true</code>. Angular classes marked as standalone do not need to be declared in an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> (the Angular compiler will report an error if you try).</p>\n\n<p translation-result=\"on\">独立组件直接指定它们的依赖项，而不是通过 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 获取它们。例如，如果 <code>PhotoGalleryComponent</code> 是独立组件，它可以直接导入另一个独立组件 <code>ImageGridComponent</code> ：</p><p translation-origin=\"off\">Standalone components specify their dependencies directly instead of getting them through <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. For example, if <code>PhotoGalleryComponent</code> is a standalone component, it can directly import another standalone component <code>ImageGridComponent</code>:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  imports: [ImageGridComponent],\n  template: `\n    ... &#x3C;image-grid [images]=\"imageList\">&#x3C;/image-grid>\n  `,\n})\nexport class PhotoGalleryComponent {\n  // component logic\n}\n</code-example>\n<p translation-result=\"on\"><code>imports</code> 也可用于引用独立指令和管道。通过这种方式，可以编写独立组件，而无需创建 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 来管理模板依赖项。</p><p translation-origin=\"off\"><code>imports</code> can also be used to reference standalone directives and pipes. In this way, standalone components can be written without the need to create an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> to manage template dependencies.</p>\n\n<h3 id=\"using-existing-ngmodules-in-a-standalone-component\" translation-result=\"on\">在独立组件中使用现有的 NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"using-existing-ngmodules-in-a-standalone-component\">Using existing NgModules in a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">编写独立组件时，你可能希望在组件的模板中使用其他组件、指令或管道。其中某些依赖项可能不会标记为独立，而是由现有的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 声明和导出。在这种情况下，你可以将 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 直接导入到独立组件中：</p><p translation-origin=\"off\">When writing a standalone component, you may want to use other components, directives, or pipes in the component's template. Some of those dependencies might not be marked as standalone, but instead declared and exported by an existing <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>. In this case, you can import the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> directly into the standalone component:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  // an existing module is imported directly into a standalone component\n  imports: [MatButtonModule],\n  template: `\n    ...\n    &#x3C;button mat-button>Next Page&#x3C;/button>\n  `,\n})\nexport class PhotoGalleryComponent {\n  // logic\n}\n</code-example>\n<p translation-result=\"on\">你可以在模板中将独立组件与现有的基于 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的库或依赖项一起使用。独立组件可以充分利用现有的 Angular 库生态系统。</p><p translation-origin=\"off\">You can use standalone components with existing <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>-based libraries or dependencies in your template. Standalone components can take full advantage of the existing ecosystem of Angular libraries.</p>\n\n<h2 id=\"using-standalone-components-in-ngmodule-based-applications\" translation-result=\"on\">在基于 NgModule 的应用程序中使用独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"using-standalone-components-in-ngmodule-based-applications\">Using standalone components in NgModule-based applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">独立组件也可以导入到现有的基于 NgModules 的上下文中。这允许现有应用程序（今天使用 NgModules）逐步采用新的独立风格的组件。</p><p translation-origin=\"off\">Standalone components can also be imported into existing NgModules-based contexts. This allows existing applications (which are using NgModules today) to incrementally adopt the new, standalone style of component.</p>\n\n<p translation-result=\"on\">你可以像导入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 一样导入独立组件（或指令或管道）- 使用 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> ：</p><p translation-origin=\"off\">You can import a standalone component (or directive, or pipe) just like you would an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> - using <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [AlbumComponent],\n  exports: [AlbumComponent], \n  imports: [PhotoGalleryComponent],\n})\nexport class AlbumModule {}\n</code-example>\n<h2 id=\"bootstrapping-an-application-using-a-standalone-component\" translation-result=\"on\">使用独立组件引导应用程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"bootstrapping-an-application-using-a-standalone-component\">Bootstrapping an application using a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通过使用独立组件作为应用程序的根组件，可以在没有任何 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情况下引导 Angular 应用程序。这是使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> API 来完成的：</p><p translation-origin=\"off\">An Angular application can be bootstrapped without any <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> by using a standalone component as the application's root component. This is done using the <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> API:</p>\n\n<code-example language=\"ts\">\n// in the main.ts file\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>} from '@angular/platform-browser';\nimport {PhotoAppComponent} from './app/photo.app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent);\n</code-example>\n<h3 id=\"configuring-dependency-injection\" translation-result=\"on\">配置依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#configuring-dependency-injection\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"configuring-dependency-injection\">Configuring dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#configuring-dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">引导应用程序时，你通常希望配置 Angular 的依赖注入并提供配置值或服务以在整个应用程序中使用。你可以将这些作为提供者传递给 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> ：</p><p translation-origin=\"off\">When bootstrapping an application, often you want to configure Angular’s dependency injection and provide configuration values or services for use throughout the application. You can pass these as providers to <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    // ...\n  ]\n});\n</code-example>\n<p translation-result=\"on\">独立的引导操作基于显式配置 <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 列表以进行依赖注入。但是，现有的库可能依赖 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 来配置 DI。例如，Angular 的路由器使用 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 帮助器在应用程序中设置路由。你可以通过 <code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> 实用程序在 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 中使用这些现有的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> ：</p><p translation-origin=\"off\">The standalone bootstrap operation is based on explicitly configuring a list of <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code>s for dependency injection. However, existing libraries may rely on <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s for configuring DI. For example, Angular’s router uses the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> helper to set up routing in an application. You can use these existing <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s in <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> via the <code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> utility:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(\n      RouterModule.forRoot([/* app routes */]),\n    ),\n    // ...\n  ]\n});\n</code-example>\n<h2 id=\"routing-and-lazy-loading\" translation-result=\"on\">路由和惰性加载<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#routing-and-lazy-loading\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"routing-and-lazy-loading\">Routing and lazy-loading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#routing-and-lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">路由器 API 进行了更新和简化，以利用独立组件的优势：在许多常见的惰性加载场景中不再需要 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p><p translation-origin=\"off\">The router APIs were updated and simplified to take advantage of the standalone components: an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> is no longer required in many common, lazy-loading scenarios.</p>\n\n<h3 id=\"lazy-loading-a-standalone-component\" translation-result=\"on\">惰性加载独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"lazy-loading-a-standalone-component\">Lazy loading a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">任何路由都可以用 <code>loadComponent</code> 惰性加载其路由到的独立组件：</p><p translation-origin=\"off\">Any route can lazily load its routed, standalone component by using <code>loadComponent</code>:</p>\n\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadComponent: () => import('./admin/panel.component').then(mod => mod.AdminPanelComponent)},\n  // ...\n];\n</code-example>\n<p translation-result=\"on\">只要加载的组件是独立的，就可以用。</p><p translation-origin=\"off\">This works as long as the loaded component is standalone.</p>\n\n<h3 id=\"lazy-loading-many-routes-at-once\" translation-result=\"on\">一次惰性加载多个路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-many-routes-at-once\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"lazy-loading-many-routes-at-once\">Lazy loading many routes at once<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-many-routes-at-once\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>loadChildren</code> 操作现在支持加载一组新的子 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>，而无需编写惰性加载的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 来导入 <code>RouterModule.forChild</code> 来声明路由。当以这种方式加载的每个路由都使用独立组件时，这会起作用。</p><p translation-origin=\"off\">The <code>loadChildren</code> operation now supports loading a new set of child <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>s without needing to write a lazy loaded <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> that imports <code>RouterModule.forChild</code> to declare the routes. This works when every route loaded this way is using a standalone component.</p>\n\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},\n  // ...\n];\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n];\n</code-example>\n<h3 id=\"providing-services-to-a-subset-of-routes\" translation-result=\"on\">为路由的子集提供服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#providing-services-to-a-subset-of-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"providing-services-to-a-subset-of-routes\">Providing services to a subset of routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#providing-services-to-a-subset-of-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的惰性加载 API ( <code>loadChildren</code> ) 在加载路由的惰性加载的子项时会创建一个新的“模块”注入器。此特性通常可用于仅向应用程序中的一部分路由提供服务。例如，如果 <code>/admin</code> 下的所有路由都使用 <code>loadChildren</code> 边界来限定范围，则可以仅向这些路由提供仅限管理的服务。执行此操作需要使用 <code>loadChildren</code> API，即使惰性加载有问题的路由不是必要的。</p><p translation-origin=\"off\">The lazy loading API for <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s (<code>loadChildren</code>) creates a new \"module\" injector when it loads the lazily loaded children of a route. This feature was often useful to provide services only to a subset of routes in the application. For example, if all routes under <code>/admin</code> were scoped using a <code>loadChildren</code> boundary, then admin-only services could be provided only to those routes. Doing this required using the <code>loadChildren</code> API, even if lazy loading of the routes in question was unnecessary.</p>\n\n<p translation-result=\"on\">路由器现在支持在 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 上显式指定其他 <code>providers</code>，这允许相同的范围限定，而无需惰性加载或 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。例如，<code>/admin</code> 路由结构中的范围服务将类似于：</p><p translation-origin=\"off\">The Router now supports explicitly specifying additional <code>providers</code> on a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>, which allows this same scoping without the need for either lazy loading or <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. For example, scoped services within an <code>/admin</code> route structure would look like:</p>\n\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {\n    path: 'admin',\n    providers: [\n      AdminService,\n      {provide: ADMIN_API_KEY, useValue: '12345'},\n    ],\n    children: [\n      path: 'users', component: AdminUsersComponent,\n      path: 'teams', component: AdminTeamsComponent,\n    ],\n  },\n  // ... other application routes that don't\n  //     have access to ADMIN_API_KEY or AdminService.\n];\n</code-example>\n<p translation-result=\"on\">也可以将 <code>providers</code> 与额外路由配置的 <code>loadChildren</code> 结合使用，以实现与惰性加载带有额外路由和路由级服务提供者的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 相同的效果。此示例配置与上面相同的提供者/子路由，但在惰性加载边界之后：</p><p translation-origin=\"off\">It's also possible to combine <code>providers</code> with <code>loadChildren</code> of additional routing configuration, to achieve the same effect of lazy loading an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> with additional routes and route-level providers. This example configures the same providers/child routes as above, but behind a lazy loaded boundary:</p>\n\n<code-example language=\"ts\">\n// Main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = {\n  // Lazy-load the admin routes.\n  {path: 'admin', loadChildren: () => import('./admin/routes').then(mod => mod.ADMIN_ROUTES)},\n  // ... rest of the routes\n}\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [{\n  path: '',\n  pathMatch: 'prefix',\n  providers: [\n    AdminService,\n    {provide: ADMIN_API_KEY, useValue: 12345},\n  ],\n  children: [\n    {path: 'users', component: AdminUsersCmp},\n    {path: 'teams', component: AdminTeamsCmp},\n  ],\n}];\n</code-example>\n<p translation-result=\"on\">请注意这里使用了空路径路由来定义供所有子路由共享的宿主 <code>providers</code>。</p><p translation-origin=\"off\">Note the use of an empty-path route to host <code>providers</code> that are shared among all the child routes.</p>\n\n<h2 id=\"advanced-topics\" translation-result=\"on\">高级主题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#advanced-topics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"advanced-topics\">Advanced topics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本节会更详细地介绍仅与更高级的使用模式相关的。第一次了解独立组件、指令和管道时，你可以安全地跳过本节。</p><p translation-origin=\"off\">This section goes into more details that are relevant only to more advanced usage patterns. You can safely skip this section when learning about standalone components, directives, and pipes for the first time. </p>\n\n<h3 id=\"standalone-components-for-library-authors\" translation-result=\"on\">针对库作者的独立组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-components-for-library-authors\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"standalone-components-for-library-authors\">Standalone components for library authors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-components-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">独立的组件、指令和管道可以从导入它们的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中导出：</p><p translation-origin=\"off\">Standalone components, directives, and pipes can be exported from <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s that import them:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ImageCarouselComponent, ImageSlideComponent],\n  exports: [ImageCarouselComponent, ImageSlideComponent],\n})\nexport class CarouselModule {}\n</code-example>\n<p translation-result=\"on\">此模式对于发布一组合作指令的 Angular 库很有用。在上面的示例中，<code>ImageCarouselComponent</code> 和 <code>ImageSlideComponent</code> 需要出现在模板中，以构建一个逻辑上的“轮播小部件”。</p><p translation-origin=\"off\">This pattern is useful for Angular libraries that publish a set of cooperating directives. In the above example, both the <code>ImageCarouselComponent</code> and <code>ImageSlideComponent</code> need to be present in a template to build up one logical \"carousel widget\". </p>\n\n<p translation-result=\"on\">作为发布 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的替代方案，库作者可能希望导出一个合作指令数组：</p><p translation-origin=\"off\">As an alternative to publishing a <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, library authors might want to export an array of cooperating directives:</p>\n\n<code-example language=\"ts\">\nexport CAROUSEL_DIRECTIVES = [ImageCarouselComponent, ImageSlideComponent] as const;\n</code-example>\n<p translation-result=\"on\">这样的数组可以由使用 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的应用程序导入并添加到 <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>。请注意 TypeScript 的 <code>as const</code> 构造的存在：它为 Angular 编译器提供了正确编译所需的额外信息，并且是一种推荐的实践（因为它使导出的数组从 TypeScript 的角度来看是不可变的）。</p><p translation-origin=\"off\">Such an array could be imported by applications using <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s and added to the <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>. Please note the presence of the TypeScript’s <code>as const</code> construct: it gives Angular compiler additional information required for proper compilation and is a recommended practice (as it makes the exported array immutable from the TypeScript point of view).</p>\n\n<h3 id=\"dependency-injection-and-injectors-hierarchy\" translation-result=\"on\">依赖注入和注入器层次结构<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#dependency-injection-and-injectors-hierarchy\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"dependency-injection-and-injectors-hierarchy\">Dependency injection and injectors hierarchy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#dependency-injection-and-injectors-hierarchy\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 应用程序可以通过指定一组可用的提供者来配置依赖注入。在典型应用中，有两种不同的注入器类型：</p><p translation-origin=\"off\">Angular applications can configure dependency injection by specifying a set of available providers. In a typical application, there are two different injector types:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">具有在 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 或 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: \"...\"})</code> 中配置的服务提供者的<strong>模块注入器</strong>。这些应用程序范围的提供者对模块注入器中配置的所有组件以及其他服务可见。</p><p translation-origin=\"off\"><strong>module injector</strong> with providers configured in <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> or <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: \"...\"})</code>. Those application-wide providers are visible to all components in as well as to other services configured in a module injector.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在 <code>@<a href=\"api/core/Directive#providers\" class=\"code-anchor\">Directive.providers</a></code> / <code>@Component.providers</code> 或 <code>@<a href=\"api/core/Component#viewProviders\" class=\"code-anchor\">Component.viewProviders</a></code> 中配置的<strong>节点注入器</strong>。这些提供程序仅对给定组件及其所有子项可见。</p><p translation-origin=\"off\"><strong>node injectors</strong> configured in <code>@<a href=\"api/core/Directive#providers\" class=\"code-anchor\">Directive.providers</a></code> / <code>@Component.providers</code> or <code>@<a href=\"api/core/Component#viewProviders\" class=\"code-anchor\">Component.viewProviders</a></code>. Those providers are visible to a given component and all its children only.</p>\n\n</li>\n</ul>\n<h4 id=\"environment-injectors\" translation-result=\"on\">环境注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#environment-injectors\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"environment-injectors\">Environment injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#environment-injectors\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">使 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 变成可选的将需要一种新方法来用应用程序范围的提供者（例如<a href=\"https://angular.io/api/common/http/HttpClient\">HttpClient</a>）配置“模块”注入器。在独立应用程序（使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 创建的）中，可以在引导过程中在 <code>providers</code> 选项中配置“模块”提供程序：</p><p translation-origin=\"off\">Making <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s optional will require new ways of configuring \"module\" injectors with application-wide providers (for example, <a href=\"https://angular.io/api/common/http/HttpClient\">HttpClient</a>). In the standalone application (one created with <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>), “module” providers can be configured during the bootstrap process, in the <code>providers</code> option: </p>\n\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    {provide: PhotosService, useClass: PhotosService},\n    // ...\n  ]\n});\n</code-example>\n<p translation-result=\"on\">新的引导 API 为我们提供了在不使用 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情况下配置“模块注入器”的方法。从这个意义上说，名称的“模块”部分不再相关，我们决定引入一个新术语：“环境注入器”。</p><p translation-origin=\"off\">The new bootstrap API gives us back the means of configuring “module injectors” without using <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. In this sense, the “module” part of the name is no longer relevant and we’ve decided to introduce a new term: “environment injectors”. </p>\n\n<p translation-result=\"on\">可以用以下方法之一配置环境注入器：</p><p translation-origin=\"off\">Environment injectors can be configured using one of the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>（在通过 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 引导的应用程序中）；</p><p translation-origin=\"off\"><code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> (in applications bootstrapping through an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>);</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({provideIn: \"...\"})</code>（在基于 NgModule 以及“独立”应用程序中）；</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({provideIn: \"...\"})</code>(in both the NgModule-based as well as “standalone” applications);</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 调用中的 <code>providers</code> 选项（在完全“独立”的应用程序中）；</p><p translation-origin=\"off\"><code>providers</code> option in the <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> call (in fully “standalone” applications);</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 配置中的 <code>providers</code> 字段。</p><p translation-origin=\"off\"><code>providers</code> field in a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> configuration.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">Angular v14 引入了一种新的 TypeScript 类型 <code><a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a></code> 来表示这种新命名。附带的 <code><a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a></code> API 使得以编程方式创建环境注入器成为可能：</p><p translation-origin=\"off\">Angular v14 introduces a new TypeScript type <code><a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a></code> to represent this new naming. The accompanying <code><a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a></code> API makes it possible to create environment injectors programmatically: </p>\n\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>} from '@angular/core';\n\nconst parentInjector = … // existing environment injector\nconst childInjector = <a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([{provide: PhotosService, useClass: CustomPhotosService}], parentInjector);\n</code-example>\n<p translation-result=\"on\">环境注入器还有一个额外的能力：它们可以在创建环境注入器时执行初始化逻辑（类似于创建模块注入器时执行的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 构造函数）：</p><p translation-origin=\"off\">Environment injectors have one additional capability: they can execute initialization logic when an environment injector gets created (similar to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> constructors that get executed when a module injector is created):</p>\n\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>, <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>} from '@angular/core';\n\n<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([\n{provide: PhotosService, useClass: CustomPhotosService},\n{provide: <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>, useValue: () => {\n        console.log(\"This function runs when this <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a> gets created\");\n}}\n]);\n</code-example>\n<h4 id=\"standalone-injectors\" translation-result=\"on\">独立注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-injectors\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"standalone-injectors\">Standalone injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-injectors\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">实际上，依赖注入器层次结构在使用独立组件的应用程序中稍微复杂一些。让我们考虑以下示例：</p><p translation-origin=\"off\">In reality, the dependency injectors hierarchy is slightly more elaborate in applications using standalone components. Let’s consider the following example:</p>\n\n<code-example language=\"ts\">\n// an existing \"datepicker\" component with an <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'datepicker',\n  template: '...',\n})\nclass DatePickerComponent {\n  constructor(private calendar: CalendarService) {}\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [DatePickerComponent],\n  exports: [DatePickerComponent]\n  providers: [CalendarService],\n})\nclass DatePickerModule {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'date-modal',\n  template: '&#x3C;datepicker>&#x3C;/datepicker>',\n  standalone: true,\n  imports: [DatePickerModule]\n})\nclass DateModalComponent {\n}\n</code-example>\n<p translation-result=\"on\">在上面的示例中，组件 <code>DateModalComponent</code> 是独立的 - 它可以直接使用，并且没有需要导入才能使用它的 NgModule。但是，<code>DateModalComponent</code> 有一个依赖项 <code>DatePickerComponent</code>，它是通过其 NgModule（<code>DatePickerModule</code>）导入的。此 NgModule 可以声明 <code>DatePickerComponent</code> 正常运行所需的提供者（在本例中为：<code>CalendarService</code>）。</p><p translation-origin=\"off\">In the above example, the component <code>DateModalComponent</code> is standalone - it can be consumed directly and has no NgModule which needs to be imported in order to use it. However, <code>DateModalComponent</code> has a dependency, the <code>DatePickerComponent,</code> which is imported via its NgModule (the <code>DatePickerModule</code>). This NgModule may declare providers (in this case: <code>CalendarService</code>) which are required for the <code>DatePickerComponent</code> to function correctly.</p>\n\n<p translation-result=\"on\">当 Angular 创建独立组件时，它需要知道当前注入器具有独立组件依赖项的所有必要服务，包括基于 NgModules 的服务。为了保证这一点，在某些情况下，Angular 会创建一个新的“独立注入器”作为当前环境注入器的子项。今天，这种情况发生在所有引导的独立组件上：它将是根环境注入器的子项。相同的规则适用于动态创建的（例如，由路由器或 <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> API）独立组件。</p><p translation-origin=\"off\">When Angular creates a standalone component, it needs to know that the current injector has all of the necessary services for the standalone component's dependencies, including those based on NgModules. To guarantee that, in some cases Angular will create a new \"standalone injector\" as a child of the current environment injector. Today, this happens for all bootstrapped standalone components: it will be a child of the root environment injector. The same rule applies to the dynamically created (for example, by the router or the <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> API) standalone components. </p>\n\n<p translation-result=\"on\">创建了一个单独的独立注入器，以确保独立组件导入的提供程序与应用程序的其余部分“隔离”。这让我们将独立组件视为真正独立的部分，不能将它们的实现细节“泄漏”给应用程序的其余部分。</p><p translation-origin=\"off\">A separate standalone injector is created to ensure that providers imported by a standalone component are “isolated” from the rest of the application. This lets us think of standalone components as truly self-contained pieces that can’t “leak” their implementation details to the rest of the application.</p>\n\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/core/Component\n - api/core/Directive\n - api/core/Pipe\n - api/core/importProvidersFrom\n - api/platform-browser\n - api/platform-browser/bootstrapApplication\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Component#viewProviders\n - api/core/Directive#providers\n - api/core/ENVIRONMENT_INITIALIZER\n - api/core/EnvironmentInjector\n - api/core/Injectable\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Provider\n - api/core/ViewContainerRef\n - api/core/createEnvironmentInjector\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - api/router/ROUTES\n - api/router/Route\n - api/router/RouterModule#forRoot\n - guide/standalone-components#advanced-topics\n - guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\n - guide/standalone-components#configuring-dependency-injection\n - guide/standalone-components#creating-standalone-components\n - guide/standalone-components#dependency-injection-and-injectors-hierarchy\n - guide/standalone-components#environment-injectors\n - guide/standalone-components#getting-started-with-standalone-components\n - guide/standalone-components#lazy-loading-a-standalone-component\n - guide/standalone-components#lazy-loading-many-routes-at-once\n - guide/standalone-components#providing-services-to-a-subset-of-routes\n - guide/standalone-components#routing-and-lazy-loading\n - guide/standalone-components#standalone-components-for-library-authors\n - guide/standalone-components#standalone-injectors\n - guide/standalone-components#the-standalone-flag-and-component-imports\n - guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\n - guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\n - https://angular.io/api/common/http/HttpClient\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/standalone-components.md?message=docs%3A%20请简述你的修改...\n-->"
}